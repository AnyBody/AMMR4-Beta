
//************ Shoulder Rhythm **********************


//This is a non linear gearing of the Elevation measure, 
//The gearing will make Elevation zero in the beginning and it will then ramp up to a gearing of one
//The idea is to keep the rhythm unchanged for high elevation but ensure the SC joints stays almost unchanged until 
//elevation reach a certain magnitude


AnyVar Limit =90;  


// AnyFunInterpol Gear ={
//       // T=        {-180,-90, -45, -40, -30, -20,  -10, -5 ,0, .Limit*0.25, .Limit*0.5  ,.Limit,150,175,200,300,400}*pi/180;
//       // Data=     {{0,    0,   0,   0,   0,   0,    0,  0 ,0,           0, .Limit*0.25 ,.Limit,150,175,200,300,400}}*pi/180;
//       Type =Bspline;
//  };

  AnyFunInterpol Gear ={

    DEFAULT_PARAMETER_FOLDER Settings(
        NPARAM = 2,
        PARAM_1 = T, PARAM_1_TYPE = AnyFloat,
        PARAM_2 = Data, PARAM_2_TYPE = AnyMatrix
    ) = {
      // Default values are located in a `Default` subfolder.
      Default.T = {-400,  -150,  -90, -50, -25,  0, 25, 50, 90, 150, 400}*pi/180;
      Default.Data = {{400,   150,   90, 50,   25 ,  0, 25, 50, 90, 150, 400}}*pi/180;
    };

      T=    Settings.T;
      Data=  Settings.Data;
      Type =Bspline;
 };



AnyKinMeasureFunComb1 Elevation_Gear =   {
  AnyKinMeasure& SternoClavicularElevation = ..InterfaceFolder.ThoraxHumerus.Elevation;
  Functions = {&.Gear};
};




AnyKinEqSimpleDriver ClaviculaProtractionDriver = 
{
  AnyKinMeasureLinComb ClaviculaProtractionRhythm = 
  {
    AnyKinMeasure& ClaviculaProtraction = ...InterfaceFolder.SternoClavicularProtraction;
    AnyKinMeasure& HumerusElevation = ..Elevation_Gear;


    AnyKinMeasure& HumerusElevationPlane = ...InterfaceFolder.ThoraxHumerus.PlaneOfElevation;
    OutDim = 1;
    Coef = {{1, 0.242, -0.12}};
    Const = -1*{(-4.983*pi/180)}; // initial position -0.401 rad + correction of +10deg
  };
  
  // Use a template to create the weight function, so
  // the weight values can be overridden by the user. 
  Template_AnyFunConst Weights (NUMBER_OF_ELEMENTS=..nDim) = {};
  //  CType= repmat(nDim,Soft);
  WeightFun ={&Weights.Fun};

  #if BM_ARM_SHOULDER_RHYTHM == _RHYTHM_SOFT_
  CType= repmat(nDim,Soft);
  #endif

  DriverPos = {0};
  DriverVel = {0};
  Reaction.Type = {Off};
};





AnyKinEqSimpleDriver ClaviculaElevationDriver = 
{
  AnyKinMeasureLinComb ClaviculaElevationRhythm = 
  {
    AnyKinMeasure& ClaviculaElevation = ...InterfaceFolder.SternoClavicularElevation;
//   AnyKinMeasure& HumerusElevation =   ...InterfaceFolder.ThoraxHumerus.Elevation;
   AnyKinMeasure& HumerusElevation =   ..Elevation_Gear;


    AnyKinMeasure& HumerusElevationPlane = ...InterfaceFolder.ThoraxHumerus.PlaneOfElevation;
    OutDim = 1;
    Coef = {{1, -0.123, 0.046}};
    Const = -1*{(3.917*pi/180)}; // initial position -0.401 rad + correction of +10deg
    
  };  
  
  // Use a template to create the weight function, so
  // the weight values can be overridden by the user. 
  Template_AnyFunConst Weights (NUMBER_OF_ELEMENTS=..nDim) = {};
  WeightFun ={&Weights.Fun};
  #if BM_ARM_SHOULDER_RHYTHM == _RHYTHM_SOFT_
  CType= repmat(nDim,Soft);
  #endif
  
  DriverPos = {0};
  DriverVel = {0};
  Reaction.Type = {Off};
};


#if BM_ARM_CLAVICULA_ROTATION_RHYTHM == OFF
AnyKinEqSimpleDriver ClaviculaAxialRotationDriver = 
{
  AnyKinMeasureLinComb ClaviculaAxialRotationRhythm = 
  {
    AnyKinMeasure& ClaviculaAxialRotation = ...InterfaceFolder.SternoClavicularAxialRotation;
    AnyKinMeasure& HumerusElevation = ...InterfaceFolder.GlenohumeralAbduction;
    OutDim = 1;
    Coef = {{1, -0.422}};
    Const = -1*{-0.423};   // initial position -0.349 rad, constant found by iteration (data non available)
  };

  // Use a template to create the weight function, so
  // the weight values can be overridden by the user. 
  Template_AnyFunConst Weights (NUMBER_OF_ELEMENTS=..nDim) = {};
  WeightFun ={&Weights.Fun};
  #if BM_ARM_SHOULDER_RHYTHM == _RHYTHM_SOFT_
  CType= repmat(nDim,Soft);
  #endif

  DriverPos = {0};
  DriverVel = {0};
  Reaction.Type = {Off};
};
#endif







